# API 类型组织说明

## 当前结构

### Services（按 Tag 分割）

```
src/services/api/
  ├── chat/                    # Chat 相关 API
  ├── sessions/                # Sessions 相关 API
  ├── messages/                # Messages 相关 API
  ├── providers/               # Providers 相关 API
  ├── authentication/          # 认证相关 API
  ├── user-management/         # 用户管理 API
  ├── tenant-management/       # 租户管理 API
  └── ...
```

### Types（统一目录）

```
src/types/api/
  ├── index.ts                                    # 统一导出
  ├── genkitAiServiceInternalModelChatRequest.ts
  ├── genkitAiServiceInternalModelSessionResponse.ts
  └── ...（所有类型定义）
```

## 为什么 Types 不按 Tag 分割？

### 1. 类型复用

很多类型会被多个 service 使用：

- `ErrorResponse` - 所有 API 都可能返回
- `SuccessResponse` - 通用成功响应
- `PaginationData` - 分页相关类型
- 通用的请求/响应包装类型

### 2. 避免循环依赖

如果按 tag 分割：

```typescript
// ❌ 可能出现的问题
// src/types/api/chat/ChatRequest.ts
import { User } from '../user/User'  // 跨 tag 引用

// src/types/api/user/User.ts
import { ChatSession } from '../chat/ChatSession'  // 循环依赖风险
```

### 3. 简化导入

统一目录让导入更简洁：

```typescript
// ✅ 当前方式 - 简洁清晰
import { ChatRequest, SessionResponse, User } from '@/types/api'

// ❌ 如果分割 - 导入复杂
import { ChatRequest } from '@/types/api/chat'
import { SessionResponse } from '@/types/api/sessions'
import { User } from '@/types/api/user'
```

## 使用建议

### 在组件中使用

```typescript
import { getChat } from '@/services/api'
import type { ChatRequest, ChatResponse } from '@/types/api'

const ChatComponent = () => {
  const chat = getChat()
  
  const handleSend = async (request: ChatRequest) => {
    const response = await chat.postChat(request)
    // ...
  }
}
```

### 配合 React Query

```typescript
import { useQuery } from '@tanstack/react-query'
import { getSessions } from '@/services/api'
import type { SessionResponse } from '@/types/api'

export const useSessions = () => {
  const sessions = getSessions()
  
  return useQuery({
    queryKey: ['sessions'],
    queryFn: sessions.getChatSessions,
  })
}
```

## 如果确实需要更好的组织

如果项目规模很大，types 文件过多，可以考虑：

### 方案 1：使用命名前缀（当前已实现）

Orval 自动生成的类型已经包含了模块前缀：

- `GenkitAiServiceInternalModelChat*` - Chat 相关
- `GenkitAiServiceInternalModelSession*` - Session 相关
- `GenkitAiServiceInternalModelUser*` - User 相关

### 方案 2：手动创建分类导出文件

在 `src/types/api/` 下创建分类导出：

```typescript
// src/types/api/chat.ts
export * from './genkitAiServiceInternalModelChatRequest'
export * from './genkitAiServiceInternalModelChatResponse'
// ...

// src/types/api/sessions.ts
export * from './genkitAiServiceInternalModelSessionRequest'
export * from './genkitAiServiceInternalModelSessionResponse'
// ...
```

使用时：

```typescript
import * as ChatTypes from '@/types/api/chat'
import * as SessionTypes from '@/types/api/sessions'
```

### 方案 3：使用 TypeScript 命名空间

```typescript
// src/types/api/namespaces.ts
export namespace Chat {
  export type Request = GenkitAiServiceInternalModelChatRequest
  export type Response = GenkitAiServiceInternalModelChatResponse
}

export namespace Session {
  export type Request = GenkitAiServiceInternalModelCreateSessionRequest
  export type Response = GenkitAiServiceInternalModelSessionResponse
}
```

使用时：

```typescript
import { Chat, Session } from '@/types/api/namespaces'

const request: Chat.Request = { ... }
const session: Session.Response = { ... }
```

## 推荐做法

对于大多数项目，**当前的统一目录结构是最佳实践**：

- ✅ 简单直接
- ✅ 避免循环依赖
- ✅ 类型复用方便
- ✅ 导入路径简洁
- ✅ 符合 Orval 的设计理念

只有在以下情况才考虑更复杂的组织方式：

- 项目有数百个类型定义
- 团队有特殊的组织需求
- 需要更细粒度的代码分割
