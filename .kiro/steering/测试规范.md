---
inclusion: fileMatch
fileMatchPattern: "**/*.{test,spec}.{ts,tsx}"
---

# 测试规范

## 测试框架

- **单元测试**: Vitest + React Testing Library
- **E2E 测试**: Playwright
- **Mock 服务**: MSW (Mock Service Worker)

## 单元测试

### 测试文件命名

- 组件测试: `ComponentName.test.tsx`
- 工具函数测试: `utils.test.ts`
- Hook 测试: `useCustomHook.test.ts`

### 测试结构

```tsx
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

describe('ComponentName', () => {
  beforeEach(() => {
    // 测试前准备
  });

  afterEach(() => {
    // 测试后清理
  });

  it('should render with default props', () => {
    render(<ComponentName />);
    expect(screen.getByRole('button')).toBeInTheDocument();
  });

  it('should handle user interaction', async () => {
    const user = userEvent.setup();
    const handleClick = vi.fn();
    
    render(<ComponentName onClick={handleClick} />);
    await user.click(screen.getByRole('button'));
    
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

### 查询优先级

按照以下优先级选择查询方法：

1. `getByRole` - 最推荐，符合可访问性
2. `getByLabelText` - 表单元素
3. `getByPlaceholderText` - 输入框
4. `getByText` - 文本内容
5. `getByTestId` - 最后选择

### 异步测试

```tsx
it('should load data asynchronously', async () => {
  render(<AsyncComponent />);
  
  // 等待元素出现
  await waitFor(() => {
    expect(screen.getByText('Loaded Data')).toBeInTheDocument();
  });
});
```

## Mock 数据

### 使用 MSW

```tsx
import { rest } from 'msw';
import { setupServer } from 'msw/node';

const server = setupServer(
  rest.get('/api/data', (req, res, ctx) => {
    return res(ctx.json({ data: 'mocked' }));
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

### Mock 函数

```tsx
import { vi } from 'vitest';

const mockFn = vi.fn();
mockFn.mockReturnValue('value');
mockFn.mockResolvedValue('async value');
```

## React Query 测试

```tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const createTestQueryClient = () => new QueryClient({
  defaultOptions: {
    queries: { retry: false },
    mutations: { retry: false },
  },
});

const wrapper = ({ children }: { children: React.ReactNode }) => (
  <QueryClientProvider client={createTestQueryClient()}>
    {children}
  </QueryClientProvider>
);

it('should fetch data', async () => {
  render(<Component />, { wrapper });
  await waitFor(() => {
    expect(screen.getByText('Data')).toBeInTheDocument();
  });
});
```

## E2E 测试

### Playwright 测试

```typescript
import { test, expect } from '@playwright/test';

test('should navigate to page', async ({ page }) => {
  await page.goto('http://localhost:3000');
  await expect(page).toHaveTitle(/Expected Title/);
});

test('should submit form', async ({ page }) => {
  await page.goto('http://localhost:3000/form');
  await page.fill('input[name="username"]', 'testuser');
  await page.click('button[type="submit"]');
  await expect(page.locator('.success-message')).toBeVisible();
});
```

## 测试覆盖率

- 目标覆盖率: 80% 以上
- 关键业务逻辑必须有测试
- 工具函数必须有完整的单元测试

## 运行测试

```bash
# 单元测试
yarn test              # 运行一次
yarn test:watch        # 监听模式
yarn test:ui           # UI 界面

# E2E 测试
yarn test:e2e          # 无头模式
yarn test:e2e:ui       # UI 模式
yarn test:e2e:headed   # 有头模式
```

## 最佳实践

1. **测试行为而非实现**: 关注用户交互和输出结果
2. **避免测试实现细节**: 不要测试内部状态或私有方法
3. **保持测试独立**: 每个测试应该独立运行
4. **使用有意义的描述**: 测试描述应该清晰表达测试意图
5. **避免过度 Mock**: 只 Mock 外部依赖
6. **测试边界情况**: 包括错误情况和边界值
7. **保持测试简单**: 一个测试只验证一个行为
