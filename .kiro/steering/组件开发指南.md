---
inclusion: fileMatch
fileMatchPattern: "src/**/*.{tsx,jsx}"
---

# React 组件开发指南

## 组件结构

### 标准组件模板

```tsx
import { FC } from 'react';
import clsx from 'clsx';

interface ComponentNameProps {
  className?: string;
  // 其他 props
}

export const ComponentName: FC<ComponentNameProps> = ({ 
  className,
  ...props 
}) => {
  return (
    <div className={clsx('base-classes', className)}>
      {/* 组件内容 */}
    </div>
  );
};
```

## Hooks 使用规范

### 状态管理

- 使用 `useState` 管理组件本地状态
- 使用 `useReducer` 处理复杂状态逻辑
- 使用 Zustand 管理跨组件共享状态
- 使用 React Query 管理服务端状态

### 副作用处理

- 使用 `useEffect` 处理副作用
- 使用 `ahooks` 提供的实用 Hooks（如 `useRequest`, `useDebounce` 等）
- 确保清理副作用以避免内存泄漏

### 性能优化

- 使用 `useMemo` 缓存计算结果
- 使用 `useCallback` 缓存函数引用
- 使用 `React.memo` 包裹纯组件

## Ant Design 集成

### 使用 Ant Design 组件

```tsx
import { Button, Form, Input, message } from 'antd';

// 优先使用 Ant Design 组件而非自定义实现
// 遵循 Ant Design 的设计规范和 API
```

### 表单处理

```tsx
import { Form } from 'antd';

const MyForm = () => {
  const [form] = Form.useForm();
  
  const onFinish = (values: any) => {
    console.log('Success:', values);
  };

  return (
    <Form form={form} onFinish={onFinish}>
      {/* 表单项 */}
    </Form>
  );
};
```

## 数据请求

### 使用 React Query

```tsx
import { useQuery, useMutation } from '@tanstack/react-query';
import { api } from '@/services/api';

const MyComponent = () => {
  const { data, isLoading, error } = useQuery({
    queryKey: ['key'],
    queryFn: () => api.fetchData(),
  });

  const mutation = useMutation({
    mutationFn: api.updateData,
    onSuccess: () => {
      // 处理成功
    },
  });

  // ...
};
```

### 使用 Axios

```tsx
import axios from 'axios';

// 使用配置好的 axios 实例
// API 请求会自动通过 Vite 代理转发
```

## 样式处理

### TailwindCSS 优先

```tsx
// 优先使用 Tailwind 工具类
<div className="flex items-center gap-4 p-4 bg-white rounded-lg shadow">
  {/* 内容 */}
</div>
```

### 条件样式

```tsx
import clsx from 'clsx';

<div className={clsx(
  'base-class',
  isActive && 'active-class',
  isDisabled && 'disabled-class',
  className
)}>
  {/* 内容 */}
</div>
```

## 类型定义

### Props 类型

```tsx
// 使用 interface 定义 Props
interface ButtonProps {
  variant?: 'primary' | 'secondary';
  size?: 'small' | 'medium' | 'large';
  onClick?: () => void;
  children: React.ReactNode;
}
```

### 事件处理类型

```tsx
const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
  // 处理点击
};

const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
  // 处理变化
};
```

## 测试

### 组件测试

```tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ComponentName } from './ComponentName';

describe('ComponentName', () => {
  it('should render correctly', () => {
    render(<ComponentName />);
    expect(screen.getByText('Expected Text')).toBeInTheDocument();
  });

  it('should handle user interaction', async () => {
    const user = userEvent.setup();
    render(<ComponentName />);
    await user.click(screen.getByRole('button'));
    // 断言
  });
});
```

## 最佳实践

1. **保持组件单一职责**: 每个组件只做一件事
2. **提取可复用逻辑**: 使用自定义 Hooks
3. **避免 prop drilling**: 使用 Context 或状态管理库
4. **合理使用 memo**: 仅在必要时使用，避免过度优化
5. **错误边界**: 使用 Error Boundary 捕获组件错误
6. **可访问性**: 确保组件符合 a11y 标准
7. **代码分割**: 使用 React.lazy() 延迟加载大型组件
